# [[], [], [], [], []]
# Первый шаг - создание поля
# Внутри каждой клетки поля мы должны хранить информацию о
# том, был ли там конь или его там еще не было
# [[False, True...], [...]]
# board[0][0] - A1

# Второй шаг - запрашиваем у пользователя начальные координаты

# Нужна какая-то функция, которая будет определять
# на какие поля может перейти конь

# все поля, на которые может перейти конь становятся True
# Мы рекурсивно вызываем ту же функцию на новое
# местоположение коня

# В нашей рекурсивной функции базовым случаем будет ситуация,
# когда коню больше некуда идти


# Вторая задача
# Начальная состояние доски
# Но оно будет представлено в виде списка цифр 4x4 от
# одного до 15 с одним пустым полем

my_dict = {"key": "value"}
my_dict["key"] = "new_value"

# Словарные выражение
lst_compr = [x**2 for x in range(10)]
# Словарь тоже можно заполнять при помощи однострочных
# циклов

numbers = [1, 2, 3, 4, 5]
# Мы хотим создать словарь пар ключ-значение, который
# будет хранить квадрат числа-ключа

# result_dictionary = {}
# for elem in numbers:
#     result_dictionary[elem] = elem ** elem

result_dictionary = {x**2: x**x for x in numbers}

# Главное отличие от случая с list - необходимость предоставить
# два выражение через двоеточие - одно для ключа, другое -
# для значения

# Точно также как и в list мы можем задавать условие
result_dictionary = {x: x**2 for x in numbers if x % 2 == 0}

# print(result_dictionary)

# new_dict = {{"a": "b"}: 1} # Мы не можем использовать изменяемые
# типы в виде ключа
new_dict = {
    "response":
        {
            "status": 404,
            "content": None
        }
}
# print(new_dict["response"]["status"])
# Обращение к вложенному словарю
inner_dict = new_dict["response"]
# print(inner_dict)
# print(inner_dict["status"])

# Объединение словарей
dict1 = {"a": 1, "b": 2}
dict2 = {"c": 3, "d": 4}
# работает как extend() в list
dict1.update(dict2) # метод update() дополняет словарь, на
# котором был применен метод вторым словарем
# Важно помнить, что метод update меняет изначальный словарь

dict1 = {"a": 1, "b": 2}
dict2 = {"c": 3, "d": 4}
# | создает новый словарь, состоящий из значений двух других
merged_dict = dict1 | dict2
print(merged_dict)


def sum_of_all_values(*args, **kwargs):
    # args - позиционные аргументы (перечисляемые через запятую)
    # my_func(1, 2, 3, 4, 5) - позиционные аргументы
    # kwargs - аргументы по ключевым словам
    # my_func(multiplier=1) - пробрасывание единицы через
    # ключевое слово multiplier
    print(args)
    print(kwargs)
    if kwargs.get("value"):
        print("Value is present")

def my_func(a, b, c):
    pass


sum_of_all_values(1, "abc", 6.7, value=9, index=56, new_key=2)

# Хэширование - односторонний алгоритм шифрования
# значение после хэширования называется хэш

# Мы не можем восстановить из хэша изначальные данные

# Работа с файлами

# работа с .txt файлами

# Для работы с файлом в python его необходимо
# открыть при помощи функции под названием open()
# В open мы передаем (<название файла>, <режим работы с файлом>)

file = open("files/example.txt", "r", encoding="utf-8")
# Функция open() лишь открывает (сохраняет в оперативной памяти)
# файл для дальнейшего с ним взаимодействия
content = file.read()
print(content)
# Главное, что стоит запомнить при работе с названиями файлов
# - мы указываем не абсолютный путь к нему
# Абсолютный путь - путь с корневого каталога ОС до нужного файла

# Режимы открытия файлов
# "r" - открытие файла для чтения (режим по умолчанию)
# file = open("non-existant-file.txt", "r")
# Не существующие файлы, открытые с режимом "r", вызывают
# ошибку

# "w" - открытие для новой записи. Создает файл,
# если его нет
# и очищает, если он существует
# file = open("non-existant-file.txt", "w")

# "x" - тоже самое, что "w", но вызывает ошибку, если
# файл уже существует

# "a" - он открывает сущесвующий файл и вместо удаление
# содержимого он добавляет новые данные в конец файла

file = open("non-existant-file.txt", "a")
file.write("\nmy data")

# "r+" - метод для чтения и записи
file = open("non-existant-file.txt", "r+")
content = file.read()
print(content)
file.write("\nFile was read")

# Чтение файла
# Метод .read() - читает файл целиком и сохраняет все его
# содержимое в строку

# метод read() принимает в качестве первого аргумента размер
# в виде количества знаком - read(1024) позволит прочесть
# первые 1024 знака

# метод readline() - считывает одну строку файла за раз
file = open("files/example.txt", "r", encoding="utf-8")
line = file.readline() # readline() запоминает, где мы остановились
# и следующий его вызов уже будет касаться следующей строки
while line:
    print(line.strip())
    line = file.readline()
