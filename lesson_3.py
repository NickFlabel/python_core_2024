# Неизменяемые и изменяемые типы данных

# В случае с изменяемыми типами данных в переменных,
# которые их содержат, хранятся не сами данные,
# а ссылка на них

# В то же время в неизменяемых данных в ячейке хранятся сами
# данные

# list - изменяемый тип
my_list = [1, 2, 3]
new_list = my_list
my_list[0] = 10
# print(my_list) # [10, 2, 3]
# print(new_list) # [10, 2, 3]

# int - неизменяемый тип
my_int = 10
new_int = my_int
my_int = 20
# print(my_int)
# print(new_int)

# str - неизменяемый тип данных
lst = [1, 2, 3]
lst[1] = 20
my_str = "my_string"
# print(my_str[1])
my_str += "_1" # оператор + создает абсолютно новое значение
# print(my_str)

# причины деления данных на изменяемые и неизменяемые
# 1 - безопасность и оптимизация
# 2 - Сохранение целостности данных

lst1 = [1, 2, 3]
lst2 = [3, 4, 5]
# print(lst1)
lst1.extend(lst2) # Добавляет второй списк к первому, не
# создавая при этом новых списков
lst3 = lst1 + lst2 # Мы создаем абсолютно новый список
# print(lst3)

# shallow copy (поверхностное копирование)
my_list = [1, 2, 3]
new_list = my_list[:] # сохранение в переменную не ссылки,
# а конкретных значений my_list то етсь [1, 2, 3]
my_list[0] = 10
# print(new_list) # [1, 2, 3]

# Другой способ поверхностного копирования
new_list = my_list.copy()

# Почему поверхностное копирование так называется
# В случае наличия в списке других изменяемых типов данных
# их изменение также повлияет и на другие переменные,
# которые хранят изначальнй список
# При этом все остальные данные будут скопированны в полном
# объеме
# [IM, IM, M] -> [значение, значение, ссылку]
lst_2d = [1, 2, [3, 4]]
new_list = lst_2d[:]
lst_2d[0] = "Элемент, который не изменится"
lst_2d[2][0] = "НОВЫЙ ЭЛЕМЕНТ"
print(new_list)

# deep copy (глубокая копия)
# глубока копия передает все значения, которые
# у нас есть


# Функции в python

# функция - это блок кода, который выполняет конкретную
# задачу и может быть использован более одного раза

# DRY - Dont Repeat Yourself (Не повторяйся)

# Основные элементы функции:
# имя - как и в случае с переменными имя функции позволяет
# ее повторно использовать
# Как в случае с переменной, в которой мы храним какие-то даныне,
# в случае с функцией мы сохраняем на будущее какую-либо
# операцию

# Аргументы(параметры) - входные данные, которые позволяют
# функции работать с разными значениями

# Возращаемое значение - функция может иметь результат своего
# исполнения и возвращать его для сохранения в какой-либо
# переменной

# синтаксис функции def <имя функции>(аргументы если есть):

def hello():
    print("hello")


def hello_with_name(name):
    print(f"hello, {name}")

hello_with_name("test_name")

# def - ключевое слово для объявления новой функции
# hello_with_name - имя функции
# (name) - последовательность аргументов (в данном случае
# только name
# : - двоеточие, которое означает, что после него идет тело
# функции
# само тело функции мы обособляем отступом
# return - то, что эта функция будет нам возвращать
# после своего выполнения

# функция, осуществляющая сложение двух элементов
# если у нас больше одного аргумента - мы
# перечисляем их через запятую
def add(a, b):
    result = a + b
    return result

result_of_my_function = add(3, 5) # функция, которая имеет
# внутри слово return возвращает то, что идет
# после этого слова, что позволяет нам сохранить этот результат
# в отдельную переменную
print(result_of_my_function)
print(add(10, 20))

# ключевое слово return:
# 1) Останавливает выполнение функции
def pring_hello():
    print("hello")
    return # возвращает программу в точку вызова функции (135 строка)
    print("world") # до этой строки программа никогда не дойдет

pring_hello()
# 2) Возвращает значение, указанное после return в точку вызова
# 3) Если return не указан или записан без значени
# то функция возвращает None по умолчанию
def empty_func(): # пустая функция возвращает None
    ... # тоже самое что pass

empty_result = empty_func()
print(empty_result) # None

def calculate_area(width, height):
    return width * height

my_rect = [10, 20]
area = calculate_area(my_rect[0], my_rect[1])
area2 = calculate_area(10, 30)

# Значение аргументов по умолчанию
def to_power(x, y=3):
    return x ** y

my_digit = to_power(2) # функция принимает два аргумента,
# но второй являеся опциональным - у него есть
# значение по умолчанию
print(my_digit)

# аргументы по ключевым словам
def print_full_name(name, surname):
    print(f"Имя: {name}, Фамилия: {surname}")

print_full_name(surname="фамилия", name="Имя")

# Встроенные функции Python
# print(x: Any) - выводит строковую репрезентацию объекта x
# в консоль
# len(x: list | str) - возвращает длинну объекта x
# int(x: Any) - превращает x в int
integer = int("11244")
# float(x: Any)
i = 1
print(float(i)) # 1.0
# str(x: Any) - превращение x в string
s = 12
my_str = str(s) + " - мое число"
print(my_str)

# Математические функции
# round(x: int | float) - функция округляет число
my_float = 1.2
print(round(my_float))
# abs(x: int | float) - модуль
print(abs(-100)) # 100
# pow(x: int | float, y: int | float) - возведение x в степень y

