# Кортежи (tuples)

# Кортеж - это неизменяемый список

my_tuple = (1, 2, 3, 4) # объявляются также как list, но
# при помощи круглых скобокк
print(my_tuple)

# Доступ к элементам кортежа осуществляется также как в
# list
print(my_tuple[1])

# Кортежи не поддерживают операции изменения такие как
# добавление, изменение и удаление элементов

# my_tuple[0] = 100 # Вызывает TypeError

# Кортежи поддерживают операции сложения и умножения
new_tuple = my_tuple + (4, 5)
print(new_tuple)
new_tuple = my_tuple * 2
print(new_tuple)
# При выполнении операций сложения и умножения создается
# новый кортеж, старый при этом остается неизменным

# Как и в случае с list я могу проверять принадлежность
# кортежу при помощи слова in

lst = [1, 2, 3]
print(10 in lst) # Проверка на принадлежность (возвращает
# True/False)
tpl = (1, 2, 3)
print(1 in tpl) # Работает также как в случае с lst


# Распаковка данных
my_tuple = (1, 2, 3)
a = my_tuple # Создает новый кортеж (1, 2, 3)
a, b, c = my_tuple # a = my_tuple[0], b = my_tuple[1] ...
print(a, b, c)

# поменять значения местами
x = 5
y = 10
x, y = y, x
print(x) # 10
print(y) # 5

# Использование распаковки в функциях
def get_coordinates():
    return (54.1, 30.5)

lat, long = get_coordinates() # Функция возвращает tuple,
# а мы можем присвоить элементы tuple в разные переменные

my_values = (1, 2, 3, 4, 5)

def my_sum(*args):
    sum = 0
    for arg in args:
        sum += arg
    return sum

print(my_sum(*my_values))

# Когда использовать кортежи и списки
# 1 - когда элементы не должны изменяться
# Если вам необходимо гарантировать, что данные
# не будут изменены, то используйте кортежи

# 2 Производительность
# Работа со списками в Python медленнее, чем в случае с
# кортежами и требует больше памяти для хранения
# индивидуальной коллекции

# 3 Когда нужно поддерживать порядок и уникальность элементов

# 4 Составные ключи в словарях - вернемся сюда после
# изучения словарей

# Когда нужно использовать list

# 1 Когда нам нужно будет изменять/добавлять/удалять
# элементы нашей коллекции

# Множества (set)

# Множества - это изменяемые, неупорядоченные коллекции
# уникальных элементов

my_set = {"first_str", "second_str", "third_str", 3, 3, 1, 5}
print(my_set)

# Неупорядоченность - множества не сохраняют порядок элементов
# Это означает, что элементы в множестве не имеют индексации
# и их порядок может изменяться при добавлении нового эл-та

# Уникальность элементов - множества могут содержать только
# уникаьные элементы. Если попытаться добавить дубликат, то
# он будет проигнорирован

# Изменяемость - множества можно изменять, добавлять или удалять
# элементы после его создания

# Мы можем хранить в множестве ТОЛЬКО неизменяемые типы данных

# my_set = {[1, 2, 3], 4} # TypeError
# print(my_set)
my_set = {(1, 2, 3), 4} # Ошибки не будет - кортеж - неизменяемый тип

# Добавление элементов
my_set.add(6) # метод .add используется для добавления
# нового элемента

# Удаление элемента
my_set.remove(6) # удаление шестерки
my_set.discard(6) # тоже самое, но не вызывает ошибку если нет значения
my_set.pop() # Удаляет случайный элемент
while my_set: # как только наш set станет пустым будет False
    elem = my_set.pop()
    print(elem)

# Операции с множествами
# Объединение |
set_a = {1, 2, 3}
set_b = {3, 4, 5}
print(set_a | set_b) # выдаст все элементы из обоих множеств
# Пересечение &
print(set_a & set_b) # выдаст все элементы, которые содержуться в
# обоих множествах
# Разность -
print(set_a - set_b) # выдаст элементы, присуствующие в первом
# множестве, но отствующие во втором


# Для чего используются множества
# Удаление дубликатов из списка
my_list = [1, 2, 2, 2, 3, 4, 4, 5]
unique_elements = set(my_list)
print(list(unique_elements)) # [1, 2, 3, 4, 5]

# Проверка наличия общих элементов между двумя списками
my_second_list = [2, 6, 6, 7, 8, 1]
common_elements = set(my_list) & set(my_second_list)
print(common_elements) # {1, 2}

# Словари
# Словари - изменяемые коллекции пар "ключ-значение", где каждый
# ключ связан с определенным значением.

# Словари создаются при помощи фигурных скобок, но в отличии от
# множеств предсвляют из себя пары <ключ>:<значение>
currency_rates = {
    "USD": 500, "EUR": 550, 1: "string", (1, 2): "tuple_key"
}
print(currency_rates["USD"])
print(currency_rates[(1, 2)])
currency_rates = dict(usd=500, eur=550)
print(currency_rates)

lst = [1, 2, [3, 4]]
# my_dict = {lst[2]: "string"} # Выдаст ошибку так как lst[2] -
# изменяемый тип

# Обращение к словарю идет при использовании ключа в следующем виде:
# <переменная, содерщая словарь>[<ключ>]
usd_rate = currency_rates["usd"]

# В случае, если ключ по которому мы обращаемся к словарю
# отсутствует то словарь выдаст нам KeyError
# currency_rates["random_currency"] # KeyError - в нашем словаре нет
# такого ключа

# метод .get(ключ) - возвращает значение по ключу и не вызывает
# KeyError если такого ключа нет

my_value = currency_rates.get("random_key")
print(my_value)

# метод .get() может также вторым аргументом предусматривать
# значение по умолчанию - в случае, если ключ отсутствует

my_value = currency_rates.get("random_key", "default_value")
print(my_value)

# добавление/изменения данных
new_dict = {"key_1": "value_1", "key_2": "value_2"}
new_dict["new_key"] = "new_value" # добавление новой пары
# ключ-значение в наш словарь
print(new_dict)
new_dict["key_1"] = "new_value_1"
print(new_dict)

# Удаление данных
del new_dict["key_1"] # удалит пару ключ-значение
print(new_dict)

# метод .keys() - возвращает все ключи в виде списка
print(new_dict.keys())

# метод .values() - возвращает все значения в виде списка
print(new_dict.values())

# метод .items() - возвращает все пары ключ-значение в виде
# списка, состоящего из кортежей, где первый элемент будет ключем,
# а второй - значением
print(new_dict.items())

# посчитать слова в тексте
text = "my I went have have done"
words = {}
lst_text = text.split(" ") # разделит текст на список из слов
for word in lst_text:
    words[word] = words.get(word, 0) # ищу в словаре слово, если его нет возвращаю ноль
    words[word] += 1 # слово встретилось - увеличиваю количество
    # на единицу
print(words)
